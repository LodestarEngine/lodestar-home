var suggestions = document.getElementById('suggestions');
var search = document.getElementById('search');

if (search !== null) {
  document.addEventListener('keydown', inputFocus);
}

function inputFocus(e) {
  if (e.ctrlKey && e.key === '/' ) {
    e.preventDefault();
    search.focus();
  }
  if (e.key === 'Escape' ) {
    search.blur();
    suggestions.classList.add('d-none');
  }
}

document.addEventListener('click', function(event) {

  var isClickInsideElement = suggestions.contains(event.target);

  if (!isClickInsideElement) {
    suggestions.classList.add('d-none');
  }

});

/*
Source:
  - https://dev.to/shubhamprakash/trap-focus-using-javascript-6a3
*/

document.addEventListener('keydown',suggestionFocus);

function suggestionFocus(e) {
  const suggestionsHidden = suggestions.classList.contains('d-none');
  if (suggestionsHidden) return;

  const focusableSuggestions= [...suggestions.querySelectorAll('a')];
  if (focusableSuggestions.length === 0) return;

  const index = focusableSuggestions.indexOf(document.activeElement);

  if (e.key === "ArrowUp") {
    e.preventDefault();
    const nextIndex = index > 0 ? index - 1 : 0;
    focusableSuggestions[nextIndex].focus();
  }
  else if (e.key === "ArrowDown") {
    e.preventDefault();
    const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
    focusableSuggestions[nextIndex].focus();
  }

}

/*
Source:
  - https://github.com/nextapps-de/flexsearch#index-documents-field-search
  - https://raw.githack.com/nextapps-de/flexsearch/master/demo/autocomplete.html
*/

(function(){

  var index = new FlexSearch.Document({
    tokenize: "forward",
    cache: 100,
    document: {
      id: 'id',
      store: [
        "href", "title", "description"
      ],
      index: ["title", "description", "content"]
    }
  });


  // Not yet supported: https://github.com/nextapps-de/flexsearch#complex-documents

  /*
  var docs = [
    {
        id: 0,
        href: "https://ldstr.dev/docs/concepts/features/",
        title: "Features",
        description: "Lodestar's feature list.",
        content: "\u003cul\u003e\n\u003cli\u003eAutomatic resolution of circular data-dependencies (algebraic loops).\u003c/li\u003e\n\u003cli\u003eTransparent compile-time error checking, as well as run-time checks prior to executing code.\u003c/li\u003e\n\u003cli\u003eEasy extensibility with a simple yet powerful \u003ccode\u003eBlock\u003c/code\u003e API based on template metaprogramming.\u003c/li\u003e\n\u003cli\u003eClean C++ code generation with predetermined function execution order, as well as resolved data-dependencies.\u003c/li\u003e\n\u003cli\u003eZero-overhead abstraction using templated classes; it does not matter if you have a thousand inputs, or just one.\u003c/li\u003e\n\u003cli\u003eOut-of-the-box networking support, with efficient serialization.\u003c/li\u003e\n\u003cli\u003eAutomatic direct encryption and decryption of messages for enhanced security using state-of-the-art elliptic curve algorithms.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"control-routines\"\u003eControl Routines \u003ca href=\"#control-routines\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFor now, this section will be a checkboxed list; more details will\nfollow. We adhere in most cases to the classification system used in\n\u003ca href=\"http://slicot.org/the-control-and-systems-library-slicot/slicot-library-organization\"\u003eSLICOT\u003c/a\u003e\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\nCursive identifiers are extensions to the SLICOT system that we devised\nfor additional features that Lodestar provides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eA\u003c/strong\u003e: Analysis Routines\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eAB\u003c/strong\u003e: State-Space Analysis\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eAB04\u003c/strong\u003e: Continuous/Discrete Time\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eAB04MD\u003c/strong\u003e: Discrete-time \u0026lt;-\u0026gt; continuous-time\nconversion by bilinear transformation.\n- Generalized bilinear transformations have been\nimplemented, with specialization for Tustin, Euler,\nand backward differencing transforms.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/analysis/BilinearTransformation.hpp\"\u003e\u003ccode lang=C++\u003els::analysis::BilinearTransformation\u003c/code\u003e\u003c/a\u003e\n- Beyond the SLICOT spec, zero-order hold\ntransformations based on exponential and logarithmic\nmatrices have been implemented.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/analysis/ZeroOrderHold.hpp\"\u003e\u003ccode lang=C++\u003els::analysis::ZeroOrderHold\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eAB07\u003c/strong\u003e: Inverse and Dual Systems\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eAB07ND\u003c/strong\u003e: Inverse of a given state-space representation\n\u003cul\u003e\n\u003cli\u003eContinuous-time state space inverses have been\nimplement, but error handling is not properly done.\n\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/analysis/LinearSystemInverse.hpp\"\u003e\u003ccode lang=C++\u003els::analysis::LinearSystemInverse\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eF\u003c/strong\u003e: Filtering\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eFB\u003c/strong\u003e: Kalman Filters\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eFB01\u003c/strong\u003e: \u003cem\u003eN/A\u003c/em\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eFB01VD\u003c/strong\u003e: One recursion of the conventional Kalman\nfilter\n- We currently have an implementation for finite\nhorizon Kalman gain computation for\ndiscrete-time linear time invariant systems.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/filter/DiscreteLQE.hpp\"\u003e\u003ccode lang=C++\u003els::filter::DiscreteLQE\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eS\u003c/strong\u003e: Synthesis Routines\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eSB\u003c/strong\u003e: State-Space Synthesis\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eSB02\u003c/strong\u003e: Riccati Equations\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eSB02MD\u003c/strong\u003e: Solution of continuous- or discrete-time\nalgebraic Riccati equations (Schur vectors method)\n- A discrete-time ARE solver is currently in\ndevelopment.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/synthesis/AlgebraicRiccatiEquation.hpp\"\u003e\u003ccode lang=C++\u003els::synthesis::AlgebraicRiccatiEquation::solveDARE\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eT\u003c/strong\u003e: Transformation Routines\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eTD\u003c/strong\u003e: Rational Matrix\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eTD05\u003c/strong\u003e: Rational Matrix to State-Space Conversion\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eTD05AD\u003c/strong\u003e: Minimal state-space representation for a\nproper transfer matrix\n- This is currently implemented for scalar transfer\nfunctions, but can easily be extended to\ntransfer function matrices.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/systems/TransferFunction.hpp\"\u003e\u003ccode lang=C++\u003els::systems::TransferFunction::toStateSpace\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eU\u003c/strong\u003e: Utility Routines\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eUD\u003c/strong\u003e: Numerical Data Handling\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eUD01\u003c/strong\u003e: \u003cem\u003eN/A\u003c/em\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003cstrong\u003eUD01BD\u003c/strong\u003e: Reading a matrix polynomial\n\u003cul\u003e\n\u003cli\u003eThis is achieved using \u003cem\u003eGiNaC\u003c/em\u003e\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e routines; currently\nonly scalar transfer functions are implemented, but\nthis is easily extendable.\u003cbr\u003e\n\u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/src/systems/TransferFunction.hpp\"\u003e\u003ccode lang=C++\u003els::systems::TransferFunction::copyFromExpression\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cem\u003e\u003cstrong\u003eUS\u003c/strong\u003e\u003c/em\u003e: \u003cem\u003eSymbolic Manipulation/Data Handling\u003c/em\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003cem\u003e\u003cstrong\u003eUS01\u003c/strong\u003e\u003c/em\u003e: \u003cem\u003eOrdinary Differential Equations\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003csection class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003cstrong\u003eSLICOT\u003c/strong\u003e: \u003ca href=\"http://slicot.org/\"\u003eSubroutine Library in Systems and Control Theory\u003c/a\u003e.\u0026#160;\u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003cstrong\u003eGiNaC\u003c/strong\u003e: \u003ca href=\"http://ginac.de/\"\u003eGiNac is Not a CAS\u003c/a\u003e (Computer Algebra System).\u0026#160;\u003ca href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n"
      },
    {
        id: 1,
        href: "https://ldstr.dev/docs/development/codestyle/",
        title: "Code Style",
        description: "Lodestar's coding guidelines.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e⚠️ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eThis is a work-in-progress. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#ifndef LODESTAR_CONTAINER_HPP\n#define LODESTAR_CONTAINER_HPP\n\n#include \u0026lt;array\u0026gt;\n// Note that we do not use `using std` to limit namespace pollution/clashes\n\n// Preprocessor directives and their arguments should be in upper snake case \n#define STATIC_GET(ARRAY, IDX) std::get\u0026lt;IDX\u0026gt;(ARRAY)\n\n// Template arguments should be descriptive, written in upper camel case, and prefixed with T*\ntemplate \u0026lt;typename TType\u0026gt;\n// Constexpr should be prefixed with K*, and the following word should be in lower camel case.\nconstexpr TType \u0026amp;Kmax(const TType \u0026amp;a, const TType \u0026amp;b)\n{   // K\u0026amp;R-style brace placement (preceded by a linebreak) for functions\n    // Indents are 4 spaces deep\n    return (int \u0026amp;) (a \u0026gt; b ? a : b);\n}\n\n// Global variables follow the same naming rules as other variables\n// Constant variables are prefixed with k*\nconst static unsigned int kDefaultSize = 10;\n\ntemplate \u0026lt;typename TType, unsigned int TSize = kDefaultSize\u0026gt;\n// Class names should be in upper camel case\nclass Container {\npublic:\n    // Typedefs should be descriptive and are prefixed with TD*\n    typedef std::array\u0026lt;TType, TSize\u0026gt; TDArray;\n\n    Container() : array_(TDArray{}) {}\n\n    explicit Container(const TDArray \u0026amp;array) : array_(array) {}\n\n    explicit Container(const TDArray *array) : array_(*array) {}\n\n    Container(const TDArray \u0026amp;array, const unsigned int end) : array_(TDArray{})\n    {\n        unsigned int i = 0;\n        while ((i \u0026lt; end) \u0026amp;\u0026amp; (i \u0026lt; TSize)) {\n            array_[i] = array[i];\n            i++;\n        }\n    }\n\n    // Use of lower camel case names is encouraged\n    void clearArray()\n    {\n        for (unsigned int i = 0; i \u0026lt; TSize; i++)\n            array_[i] = TType{};\n    }\n\n    TType getElement(const unsigned int idx) const\n    {\n        return array_[idx];\n    }\n\n    void setElement(const unsigned int idx, const TType \u0026amp;val)\n    {\n        array_[idx] = val;\n    }\n\n    TDArray copyArray() const {\n        return array_;\n    }\n\n    void copyContainer(const Container \u0026amp;other) const\n    {\n        for (unsigned int i = 0; i \u0026lt; TSize; i++)\n            array_[i] = other.getElement(i);\n    }\n\n    TType getFirst() const\n    {\n        return STATIC_GET(array_, 0);\n    }\n\n    TType getLast() const\n    {\n        return STATIC_GET(array_, Kmax(0, TSize - 1));\n    }\n\n    const unsigned int kSize = TSize;\nprotected:\n    // Private/protected member variables are postfixed with *_\n    std::array\u0026lt;TType, TSize\u0026gt; array_;\n\n    // Static members may be prefixed with z* in case of ambiguities\n    template\u0026lt;unsigned int TSizeOther\u0026gt;\n    Container\u0026lt;TType, TSize\u0026gt; zCopyContainer(const Container\u0026lt;TType, TSizeOther\u0026gt; \u0026amp;other)\n    {\n        Container\u0026lt;TType, TSize\u0026gt; container{};\n\n        unsigned int i = 0;\n        while ((i \u0026lt; other.kSize) \u0026amp;\u0026amp; (i \u0026lt; TSize))\n            container.setElement(i, other.getElement(i));\n        \n        return container;\n    }\n}\n\n// Preprocessor directives should be undef'd if they are not part of the public API\n#undef STATIC_GET\n\n#endif //LODESTAR_CONTAINER_HPP\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 2,
        href: "https://ldstr.dev/docs/blocks/gainblock/",
        title: "GainBlock",
        description: "Multiplication or convolution by a constant value.",
        content: "\u003ch2 id=\"description\"\u003eDescription \u003ca href=\"#description\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eMultiplies/convolves input by a value (gain).\u003c/p\u003e\n\u003ch2 id=\"interface-definition\"\u003eInterface Definition \u003ca href=\"#interface-definition\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eGainBlock\u0026lt;TInput, TGain, TOps, TConv\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"template-parameters\"\u003eTemplate Parameters \u003ca href=\"#template-parameters\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eIndex\u003c/th\u003e\n\u003cth\u003eParameter type\u003c/th\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003cth\u003eDefault value\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e0\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003etypename\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTInput\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eInput value type\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e1\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003etypename\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTGain\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eGain value type\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTInput\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e2\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eGainBlockOperator\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTOps\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eGain block operator type\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e::Left\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e3\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eGainBlockConvolutionMode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTConv\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eGain block convolution type\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e::Reflect\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"inputs\"\u003eInputs \u003ca href=\"#inputs\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eIndex\u003c/th\u003e\n\u003cth\u003eParameter type\u003c/th\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003cth\u003eDefault value\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e0\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e\u0026lt;TInput\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003eInput value\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"outputs\"\u003eOutputs \u003ca href=\"#outputs\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eIndex\u003c/th\u003e\n\u003cth\u003eParameter type\u003c/th\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003cth\u003eDefault value\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e0\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e\u0026lt;TOutput\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003eOutput value\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eDetermination of \u003ccode\u003eTOutput\u003c/code\u003e is not straightforward; in the case of multiplication, we must first check if multiplication is possible.\nIn the case of a scalar gain, or convolution, the output type is the same as \u003ccode\u003eTInput\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"parameters\"\u003eParameters \u003ca href=\"#parameters\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eIndex\u003c/th\u003e\n\u003cth\u003eParameter type\u003c/th\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003cth\u003eDefault value\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e0\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e\u0026lt;TGain\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egain\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eGain value\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e1\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003edouble\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003econstant\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eConstant value\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThe function of \u003ccode\u003egain\u003c/code\u003e varies with \u003ccode\u003eTOps\u003c/code\u003e; see \u003ca href=\"#effects\"\u003eEffects\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"effects\"\u003eEffects \u003ca href=\"#effects\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIf \u003ccode\u003eTOps\u003c/code\u003e is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e::Left\u003c/code\u003e, left-multiply the input by the gain.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Right\u003c/code\u003e, right-multiply the input by the gain.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Convolution\u003c/code\u003e, convolve the input with the gain, where the boundary condition is determined by \u003ccode\u003eTConv\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf \u003ccode\u003eTOps\u003c/code\u003e is \u003ccode\u003e::Convolution\u003c/code\u003e, and \u003ccode\u003eTConv\u003c/code\u003e is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e::Reflect\u003c/code\u003e, reflect about the edge of the last pixel. Also known as half-sample symmetric.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Constant\u003c/code\u003e, fill all values beyond edges with a constant value (see parameter 1 in \u003ca href=\"#parameters\"\u003eParameters\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Nearest\u003c/code\u003e, extend by replicating last pixel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Mirror\u003c/code\u003e, extend by reflecting about the center of the last pixel. Also known as whole-sample symmetric.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::Wrap\u003c/code\u003e, wrap around to the opposing edge.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"static-asserts\"\u003eStatic Asserts \u003ca href=\"#static-asserts\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMultiplicability in case of \u003ccode\u003eTOps\u003c/code\u003e in \u003ccode\u003e{::Left, ::Right}\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eScalar type congruence in case of \u003ccode\u003eTOps = ::Convolution\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n"
      },
    {
        id: 3,
        href: "https://ldstr.dev/docs/prologue/introduction/",
        title: "Introduction",
        description: "Lodestar is a lightweight C++11 framework for rapidly prototyping and deploying real-time control systems.",
        content: "\u003cp\u003e\u003cem\u003eLodestar\u003c/em\u003e aims to be a framework that provides \u003cem\u003edirectly executable code\u003c/em\u003e, unlike most modeling and simulation-centric\ntoolboxes, which have not been tailored for use in real-time applications. At the same time, \u003cem\u003eLodestar\u003c/em\u003e also allows for\n\u003cem\u003ecode generation\u003c/em\u003e when performance is particularly important. It comes built-in with many compile-time checks that cover\nmost common typos and bugs (i.e., matrix-vector dimensions mismatch, connecting inputs to inputs, etc.).\u003c/p\u003e\n\u003cp\u003eTo this end, \u003cem\u003eLodestar\u003c/em\u003e adopts a function block description of systems, where\neach \u003ccode\u003eBlock\u003c/code\u003e provides a \u003cem\u003epure function\u003c/em\u003e (i.e., one that only alters its internal state). Each of these block may have\nany number of inputs, parameters, and outputs. The resulting functional block diagrams can easily be extended with new\nuser-defined block types, without incurring overhead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                           Parameters\n           +-----------------------------------------+\nInputs ---\u0026gt;| Block : f(Input, Parameters) -\u0026gt; Outputs |---\u0026gt; Outputs\n           +-----------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"features\"\u003eFeatures \u003ca href=\"#features\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAutomatic resolution of circular data-dependencies (algebraic loops).\u003c/li\u003e\n\u003cli\u003eTransparent compile-time error checking, as well as run-time checks prior to executing code.\u003c/li\u003e\n\u003cli\u003eEasy extensibility with a simple yet powerful \u003ccode\u003eBlock\u003c/code\u003e API based on template metaprogramming.\u003c/li\u003e\n\u003cli\u003eClean C++ code generation with predetermined function execution order, as well as resolved data-dependencies.\u003c/li\u003e\n\u003cli\u003eZero-overhead abstraction using templated classes; it does not matter if you have a thousand inputs, or just one.\u003c/li\u003e\n\u003cli\u003eOut-of-the-box networking support, with efficient serialization.\u003c/li\u003e\n\u003cli\u003eAutomatic direct encryption and decryption of messages for enhanced security using state-of-the-art elliptic curve algorithms.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"getting-started\"\u003eGetting Started \u003ca href=\"#getting-started\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"dependencies\"\u003eDependencies \u003ca href=\"#dependencies\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCMake\u003c/li\u003e\n\u003cli\u003eA C++11-compliant compiler\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ginac.de/\"\u003eGiNaC\u003c/a\u003e (optional, for resolving algebraic loops)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nng.nanomsg.org/\"\u003enng\u003c/a\u003e (optional, for networking)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"building\"\u003eBuilding \u003ca href=\"#building\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSimply clone the \u003ca href=\"https://github.com/helkebir/Lodestar\"\u003erepository\u003c/a\u003e and build using CMake.\nIf you just want to grab a static library, run \u003ccode\u003ecmake ..\u003c/code\u003e instead of a debug build.\u003c/p\u003e\n\u003cdetails\u003e\n  \u003csummary\u003eInstalling/disabling dependencies\u003c/summary\u003e\n  \u003cp\u003eYou can install the dependencies as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOn Ubuntu (Debian):\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esudo apt-get install libginac-dev libcln-dev libnng-dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eOn macOS:\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ebrew install ginac nng\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can disable GiNaC and NNG using the \u003ccode\u003e-DWITH_GINAC=OFF -DWITH_NNG=OFF\u003c/code\u003e flags when running the \u003ccode\u003ecmake\u003c/code\u003e command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecmake .. -DCMAKE_BUILD_TYPE=Debug -DWITH_GINAC=OFF -DWITH_NNG=OFF\u003c/code\u003e\u003c/p\u003e\n\u003c/details\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/helkebir/Lodestar\ncd Lodestar\nmkdir build \u0026amp;\u0026amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Debug\nmake\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can find some demos in the \u003ccode\u003eexamples/\u003c/code\u003e folder, as well as unit tests of different components in the \u003ccode\u003etests/\u003c/code\u003e folder.\u003c/p\u003e\n"
      },
    {
        id: 4,
        href: "https://ldstr.dev/docs/recipes/pid/",
        title: "PID Controller",
        description: "A simple proportional-integral-derivative controller.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e❓ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eFor more background on PID controllers, see \u003ca href=\"https://theory.ldstr.dev/pid/\"\u003ethis theory page\u003c/a\u003e. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eIn this recipe, we will prepare a simple discretized PID controller. As a bonus, we show how to take this prebaked controller to the next level by programming a PID controller with anti-windup from scratch.\u003c/p\u003e\n\u003ch2 id=\"gathering-the-ingredients\"\u003eGathering the Ingredients \u003ca href=\"#gathering-the-ingredients\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eYou will need the following standard library blocks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eConstantBlock\u003c/code\u003e, for a constant setpoint.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSumBlock\u003c/code\u003e, to add and subtract signals.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGainBlock\u003c/code\u003e, to multiply signals with a fixed gain.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInclude them as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;Lodestar/blocks/std/ConstantBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/SumBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/GainBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/SimplePIDBlock.hpp\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make life easier for ourselves and reduce the amount of typing, let\u0026rsquo;s add the following two \u003ccode\u003eusing namespace\u003c/code\u003e declarations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eusing namespace ls::blocks;\nusing namespace ls::blocks::std;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e⚠️ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eUsing `using` declarations pollutes your namespace and can cause name clashes; use them in moderation. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003ch2 id=\"preparing-the-blocks\"\u003ePreparing the Blocks \u003ca href=\"#preparing-the-blocks\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe start by declaring our constant setpoint, which we assume to be a \u003ccode\u003edouble\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eConstantBlock\u0026lt;double\u0026gt; constBlk{0.5};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can change the constant any time before running the loop as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003econstBlk.constant() = -0.5;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e⚠️ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eDon't change constants while your program is running; there are better ways of doing this (shown just below). \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eNow it\u0026rsquo;s time to introduce the summation that computes our error (setpoint minus the system\u0026rsquo;s output):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e// The number of inputs to the summation is 2, and the type is `double`, hence \u0026lt;double, 2\u0026gt;.\nSumBlock\u0026lt;double, 2\u0026gt; sumBlk;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou should know that a \u003ccode\u003eSumBlock\u003c/code\u003e assumes that all its inputs should just be added; we want to subtract the second input. To do this, we set the operators as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003esumBlk.setOperators(decltype(sumBlk)::Plus, decltype(sumBlk)::Minus);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, everything is ready for a PID controller. We are taking a shortcut here, directly using the \u003ccode\u003eSimplePIDBlock\u003c/code\u003e (don\u0026rsquo;t worry, a more advanced example follows just after this).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eSimplePIDBlock\u0026lt;double\u0026gt; pidBlk;\npidBlk.pGain() = 1;\npidBlk.iGain() = 0.2;\npidBlk.dGain() = 0.1;\npidBlk.samplingPeriod() = 1e-3;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBased on the code above, it should be clear that we are setting the proportional, derivative, and integral gains, as well as the sampling period, in that exact order. We link these blocks together next.\u003c/p\u003e\n\u003ch2 id=\"linking-the-blocks\"\u003eLinking the Blocks \u003ca href=\"#linking-the-blocks\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe will need to introduce two more \u003ccode\u003einclude\u003c/code\u003es add the top of the code: one for our \u003ccode\u003econnect\u003c/code\u003e function, and the other for the \u003ccode\u003eExecutor\u003c/code\u003e, which will figure out how to run our blocks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;Lodestar/blocks/BlockUtilities.hpp\u0026gt; // connect function\n#include \u0026lt;Lodestar/blocks/aux/Executor.hpp\u0026gt; // Executor\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe\u0026rsquo;re now getting to the fun part: connecting the blocks. It should be quite obvious to see what we\u0026rsquo;re after: the error should go into the PID block, and the constant should go into the first input of the sum.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003econnect(sumBlk.o\u0026lt;0\u0026gt;(), pidBlk.i\u0026lt;0\u0026gt;());\nconnect(constBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;0\u0026gt;());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere\u0026rsquo;s a pro tip for when you start taking on more advanced systems; you can \u003cem\u003ealias\u003c/em\u003e signals as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eauto \u0026amp;e = sumBlk.o\u0026lt;0\u0026gt;();\nauto \u0026amp;s0 = sumBlk.i\u0026lt;0\u0026gt;();\nauto \u0026amp;s1 = sumBlk.i\u0026lt;1\u0026gt;();\nauto \u0026amp;sp = constBlk.o\u0026lt;0\u0026gt;();\nauto \u0026amp;pid = pidBlk.i\u0026lt;0\u0026gt;();\nauto \u0026amp;u = pidBlk.o\u0026lt;0\u0026gt;();\n\nconnect(sp, s0);\nconnect(e, pid);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you keep track of your naming conventions, this can feel a lot closer to drawing a block diagram by hand!\u003c/p\u003e\n\u003ch2 id=\"executing-the-program\"\u003eExecuting the Program \u003ca href=\"#executing-the-program\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe\u0026rsquo;re missing one crucial component: a physical system. This is were the possibilities start to expand; you can declare your \u003cem\u003eown\u003c/em\u003e blocks in Lodestar and directly interface with them.\u003c/p\u003e\n\u003cp\u003eFor now, let\u0026rsquo;s keep things simple, going for a one-step time delay (\u003ccode\u003eDelayBlock\u003c/code\u003e) instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;Lodestar/blocks/std/DelayBlock.hpp\u0026gt;\n\nDelayBlock\u0026lt;double\u0026gt; sysBlk;\n// Set the initial value to be 5.\nsysBlk.clear(5);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final interconnections read:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003econnect(pidBlk.o\u0026lt;0\u0026gt;(), sysBlk.i\u0026lt;0\u0026gt;());\nconnect(sysBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;1\u0026gt;());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr, in case you\u0026rsquo;re using those handy aliases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003econnect(u, sysBlk.i\u0026lt;0\u0026gt;());\nconnect(sysBlk.o\u0026lt;0\u0026gt;(), s1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e⚠️ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eBe aware of your `connection`s; Lodestar will complain if you connect incompatible signals, or if you try to connect two or more outputs to a single input. Also, you can't use and input as an output (for obvious reasons). \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eWe\u0026rsquo;re now ready to run the code. First, however, we need to let Lodestar know what we\u0026rsquo;re working with. To do that, Lodestar uses \u003ccode\u003eBlockPack\u003c/code\u003es; as the name suggests, these are packs of blocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eBlockPack bp{pidBlk, constBlk, sumBlk, sysBlk};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we can pass this \u003ccode\u003eBlockPack\u003c/code\u003e to an \u003ccode\u003eExecutor\u003c/code\u003e, which allows us to resolve the execution order:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eaux::Executor ex{bp};\nex.resolveExecutionOrder();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it, you can now run a single iteration of your loop (known as \u003ccode\u003etrigger\u003c/code\u003eing in Lodestar parlance):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eex.trigger();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo actually see our program in action, let\u0026rsquo;s include \u003ccode\u003e\u0026lt;iostream\u0026gt;\u003c/code\u003e, and run the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efor (int i=0; i\u0026lt;50; i++) {\n    ex.trigger();\n    \n    // Print the system output\n    ::std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; sysBlk.o\u0026lt;0\u0026gt;().object \u0026lt;\u0026lt; ::std::endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd there you have it, your first PID controller in Lodestar!\u003c/p\u003e\n\u003ch2 id=\"going-beyond\"\u003eGoing Beyond \u003ca href=\"#going-beyond\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe will need some more blocks to cook up our \u003cem\u003eadvanced\u003c/em\u003e PID controller:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSaturationBlock\u003c/code\u003e, to limit our integral value.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDeadzoneBlock\u003c/code\u003e, to prevent small oscillations in case of small errors.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDelayBlock\u003c/code\u003e, to be able to perform Euler integration and backward differentiation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;Lodestar/blocks/std/SaturationBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/DeadzoneBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/DelayBlock.hpp\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, for the block initialization:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eGainBlock\u0026lt;double\u0026gt; Kp{1};\nGainBlock\u0026lt;double\u0026gt; Ki{0.2};\nGainBlock\u0026lt;double\u0026gt; Kd{0.1};\nGainBlock\u0026lt;double\u0026gt; periodInv{1e3};\nGainBlock\u0026lt;double\u0026gt; period{1e-3};\n\nDelayBlock\u0026lt;double\u0026gt; delayDiff, delayInt;\n\nSaturationBlock\u0026lt;double\u0026gt; satInt;\n\nsatInt.lower() = -1;\nsatInt.upper() = 1;\n\nSumBlock\u0026lt;double, 2\u0026gt; sumDiff, sumInt;\nsumDiff.setOperators(decltype(sumDiff)::Plus, decltype(sumDiff)::Minus);\n\nSumBlock\u0026lt;double, 3\u0026gt; sumPID;\n\nSaturationBlock\u0026lt;double\u0026gt; satBlk;\nsatBlk.lower() = -2;\nsatBlk.upper() = 2;\n\nDeadzoneBlock\u0026lt;double\u0026gt; dzBlk;\ndzBlk.lower() = -0.05;\ndzBlk.upper() = 0.05;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can see that we introduced a couple of gains, some delays and sums, and a saturation and deadzone block. Initializing these block is pretty straightforward as shown.\nWe can now start linking them together.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e// Proportional\nconnect(sumBlk.o\u0026lt;0\u0026gt;(), Kp.i\u0026lt;0\u0026gt;());\nconnect(Kp.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;0\u0026gt;());\n\n// Integral\nconnect(sumInt.o\u0026lt;0\u0026gt;(), satInt.i\u0026lt;0\u0026gt;());\nconnect(satInt.o\u0026lt;0\u0026gt;(), delayInt.i\u0026lt;0\u0026gt;());\nconnect(delayInt.o\u0026lt;0\u0026gt;(), sumInt.i\u0026lt;0\u0026gt;());\nconnect(sumBlk.o\u0026lt;0\u0026gt;(), period.i\u0026lt;0\u0026gt;());\nconnect(period.o\u0026lt;0\u0026gt;(), sumInt.i\u0026lt;1\u0026gt;());\nconnect(satInt.o\u0026lt;0\u0026gt;(), Ki.i\u0026lt;0\u0026gt;());\nconnect(Ki.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;1\u0026gt;());\n\n// Differential\nconnect(sumBlk.o\u0026lt;0\u0026gt;(), sumDiff.i\u0026lt;0\u0026gt;());\nconnect(sumBlk.o\u0026lt;0\u0026gt;(), delayDiff.i\u0026lt;0\u0026gt;());\nconnect(delayDiff.o\u0026lt;0\u0026gt;(), sumDiff.i\u0026lt;1\u0026gt;());\nconnect(sumDiff.o\u0026lt;0\u0026gt;(), periodInv.i\u0026lt;0\u0026gt;());\nconnect(periodInv.o\u0026lt;0\u0026gt;(), Kd.i\u0026lt;0\u0026gt;());\nconnect(Kd.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;2\u0026gt;());\n\n// Error computation\nconnect(constBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;0\u0026gt;());\nconnect(dzBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;1\u0026gt;());\n\n// Saturation\nconnect(sumPID.o\u0026lt;0\u0026gt;(), satBlk.i\u0026lt;0\u0026gt;());\n\n// Deadzone\nconnect(sysBlk.o\u0026lt;0\u0026gt;(), dzBlk.i\u0026lt;0\u0026gt;());\n\n// Control interconnection\nconnect(satBlk.o\u0026lt;0\u0026gt;(), sysBlk.i\u0026lt;0\u0026gt;());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMost of the code above is straightforward, but the integral and differential parts might need to be reread to see how things link up. This is where a block diagram could come in handy (Lodestar can generate those for you, but we\u0026rsquo;ll get into that in another article!).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eBlockPack\u003c/code\u003e-\u003ccode\u003eExecutor\u003c/code\u003e interaction is the same as above, but now we have a couple more blocks to declare:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eBlockPack bp{sysBlk, constBlk, sumBlk, satBlk, sumDiff, sumInt, sumPID, satInt,\n             Kp, Ki, Kd, period, periodInv, delayInt, delayDiff};\n\naux::Executor ex{bp};\nex.resolveExecutionOrder();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTry running the code below and see what has changed:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efor (int i=0; i\u0026lt;50; i++) {\n    ex.trigger();\n    \n    // Print the system output\n    ::std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; sysBlk.o\u0026lt;0\u0026gt;().object \u0026lt;\u0026lt; ::std::endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 5,
        href: "https://ldstr.dev/docs/concepts/rationale/",
        title: "Rationale",
        description: "Rationale behind Lodestar.",
        content: "\u003cp\u003eThe greatest driver behind this project is the lack of a fast and\naccessible library for applying control theoretic concepts on real-life\n(embedded) systems. While platforms such as\n\u003ca href=\"https://www.ros.org/\"\u003eROS\u003c/a\u003e\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e are popular in robotics, people\nworking with applications that require real-time viable code and thread\nsafety are often compelled to write their own solutions, with\npropiertary implementations being the norm, and a single unified\nsolution is left to be desired.\u003c/p\u003e\n\u003cp\u003eWith this in mind, I set out to develop a unified and approachable\ncontrol library, with the explicit intention to make it as real-time\nviable as possible while maintaining code transparency and providing a\nflexible API\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eFor more information, please check out our paper on arXiv entitled \u003ca href=\"https://arxiv.org/abs/2203.00649\"\u003e\u0026ldquo;Lodestar: An Integrated Embedded Real-Time Control Engine\u0026rdquo;\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"core-principles\"\u003eCore Principles \u003ca href=\"#core-principles\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLodestar is built on the following core principles:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cem\u003eFirm real-time\u003c/em\u003e first\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eMemory demands should be known at compile-time, minimum/no dynamic\nmemory allocation/paging.\u003c/li\u003e\n\u003cli\u003eDynamically and statically allocated objects should share a common\nAPI.\u003c/li\u003e\n\u003cli\u003eExceptions should be thrown with care; status-based fallbacks are\npreferred.\u003c/li\u003e\n\u003cli\u003eProcesses should be timed, with fallback mechanisms and deadline\nviolation reporting.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWide platform support\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eMaintain minimum demands should be imposed on compiled libraries,\npreferring header-only libraries instead.\u003c/li\u003e\n\u003cli\u003eUse only ISO/ANSI C++11 features.\u003c/li\u003e\n\u003cli\u003eMake full use of POSIX\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e RT (real-time) mechanisms\n(\u003ccode\u003epthread\u003c/code\u003es, \u003ccode\u003esigaction\u003c/code\u003es, etc.).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFlexible interfacing and extension\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eExtendible, documented, and transparent core API.\u003c/li\u003e\n\u003cli\u003eInproc and outproc non-blocking communication framework.\u003c/li\u003e\n\u003cli\u003eThread-safe data types, with object-bound \u003ccode\u003emutex\u003c/code\u003ees.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"levels-of-real-time\"\u003eLevels of Real-time \u003ca href=\"#levels-of-real-time\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe following is a common classification of levels of real-time:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSoft real-time\u003c/strong\u003e: Delayed process completion may degrade a system\u0026rsquo;s\nquality of service, but is tolerable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFirm real-time\u003c/strong\u003e: Delayed process completion may degrade a system\u0026rsquo;s\nquality of service, but is tolerable if infrequent.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard real-time\u003c/strong\u003e: Delayed process completion results in system\nfailure.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAt least for the initial stages, Lodestar will try to get to the level\nwhere one could reliably call it a firm real-time framework. With\nsufficient testing and profiling in a hardware emulator, it is possible\nto extend a firm real-time system to a hard real-time system, but it\ncould be the case that additional safety features and fallbacks are\nexpected. This is, for now, beyond the scope of the library.\u003c/p\u003e\n\u003csection class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003cstrong\u003eROS\u003c/strong\u003e: Robot Operating System.\u0026#160;\u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003cstrong\u003eAPI\u003c/strong\u003e: Application Programming Interface.\u0026#160;\u003ca href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003cstrong\u003ePOSIX\u003c/strong\u003e: Portable Operating System Interface, a family of standards\ndescribed in IEEE 1003 and ISO/IEC 9945.\u0026#160;\u003ca href=\"#fnref:3\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n"
      },
    {
        id: 6,
        href: "https://ldstr.dev/docs/recipes/lqr/",
        title: "LQR Controller",
        description: "A linear quadratic regulator.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e⚠️ \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eThis is a work-in-progress. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eSee \u003ca href=\"https://github.com/helkebir/Lodestar/blob/master/examples/CarDemo.cpp\"\u003ethis example\u003c/a\u003e for now.\u003c/p\u003e\n"
      },
    {
        id: 7,
        href: "https://ldstr.dev/docs/prologue/quick-start/",
        title: "Quick Start",
        description: "How to get started with Lodestar.",
        content: "\u003ch2 id=\"dependencies\"\u003eDependencies \u003ca href=\"#dependencies\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCMake\u003c/li\u003e\n\u003cli\u003eA C++11-compliant compiler\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ginac.de/\"\u003eGiNaC\u003c/a\u003e (optional, for resolving algebraic loops)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nng.nanomsg.org/\"\u003enng\u003c/a\u003e (optional, for networking)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"building\"\u003eBuilding \u003ca href=\"#building\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSimply clone the \u003ca href=\"https://github.com/helkebir/Lodestar\"\u003erepository\u003c/a\u003e and build using CMake.\nIf you just want to grab a static library, run \u003ccode\u003ecmake ..\u003c/code\u003e instead of a debug build.\u003c/p\u003e\n\u003cdetails\u003e\n  \u003csummary\u003eInstalling/disabling dependencies\u003c/summary\u003e\n  \u003cp\u003eYou can install the dependencies as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOn Ubuntu (Debian):\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esudo apt-get install libginac-dev libcln-dev libnng-dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eOn macOS:\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ebrew install ginac nng\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can disable GiNaC and NNG using the \u003ccode\u003e-DWITH_GINAC=OFF -DWITH_NNG=OFF\u003c/code\u003e flags when running the \u003ccode\u003ecmake\u003c/code\u003e command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecmake .. -DCMAKE_BUILD_TYPE=Debug -DWITH_GINAC=OFF -DWITH_NNG=OFF\u003c/code\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003c/details\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/helkebir/Lodestar\ncd Lodestar\nmkdir build \u0026amp;\u0026amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Debug\nmake\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can find some demos in the \u003ccode\u003eexamples/\u003c/code\u003e folder, as well as unit tests of different components in the \u003ccode\u003etests/\u003c/code\u003e folder.\u003c/p\u003e\n\u003ch2 id=\"first-example\"\u003eFirst Example \u003ca href=\"#first-example\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eHere\u0026rsquo;s an example to get you started. We will be using \u003ccode\u003eConstantBlock\u003c/code\u003e, \u003ccode\u003eSumBlock\u003c/code\u003e, and \u003ccode\u003eGainBlock\u003c/code\u003e objects to construct\na simple program.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;Lodestar/blocks/std/ConstantBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/SumBlock.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/std/GainBlock.hpp\u0026gt;\n\n#include \u0026lt;Lodestar/blocks/BlockUtilities.hpp\u0026gt;\n#include \u0026lt;Lodestar/blocks/aux/Executor.hpp\u0026gt;\n\nusing namespace ls::blocks;\nusing namespace ls::blocks::std;\n\n/*\n *                (+)\n * +---+    +---+    +---+\n * | c |---\u0026gt;| g |---\u0026gt;| s |---\u0026gt;\n * +---+    +---+    +---+\n *                     ^ (-)\n * +----+              |\n * | c2 |--------------+\n * +----+\n */\n\nint main()\n{\n    ConstantBlock\u0026lt;double\u0026gt; c{5}, c2{2};\n    SumBlock\u0026lt;double, 2\u0026gt; s;\n    GainBlock\u0026lt;double\u0026gt; g{0.5};\n    \n    s.setOperators(decltype(s)::Plus, decltype(s)::Minus);\n    \n    // We now establish the interconnections:\n    connect(c.o\u0026lt;0\u0026gt;(), g.i\u0026lt;0\u0026gt;());\n    connect(g.o\u0026lt;0\u0026gt;(), s.i\u0026lt;0\u0026gt;());\n    connect(c2.o\u0026lt;0\u0026gt;(), s.i\u0026lt;1\u0026gt;());\n    \n    // We group all our blocks in a BlockPack object,\n    // which contains all components of our system.\n    BlockPack bp{c, c2, s, g};\n    \n    // We pass the BlockPack onto the Executor,\n    // which will allow us to resolve the execution order,\n    // providing a single trigger function for the entire system.\n    aux::Executor ex{bp};\n    ex.resolveExecutionOrder();\n\n    // Triggering the entire system is as simple as\n    // calling the trigger function of the executor.\n    ex.trigger();\n    \n    // We obtain +5*0.5 -2 = 0.5  \n    auto res = (s.o\u0026lt;0\u0026gt;().object == 0.5);\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"next-steps\"\u003eNext Steps \u003ca href=\"#next-steps\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLook around in the sidebar on the left to read on whatever topic is of direct interest. We recommend browsing through the \u003ca href=\"/docs/concepts\"\u003eConcepts\u003c/a\u003e tab, especially the \u003ca href=\"/docs/concepts/rationale\"\u003eRationale\u003c/a\u003e. Some assorted code snippets and recipes are laid out in the \u003ca href=\"/recipes/\"\u003eRecipes\u003c/a\u003e section. If you want to directly dive into the source code, check out the \u003ca href=\"/doxygen\"\u003eC++ reference\u003c/a\u003e.\u003c/p\u003e\n"
      },
    {
        id: 8,
        href: "https://ldstr.dev/docs/blocks/",
        title: "Blocks",
        description: "Lodstar blocks.",
        content: ""
      },
    {
        id: 9,
        href: "https://ldstr.dev/docs/concepts/",
        title: "Concepts",
        description: "Lodestar concepts.",
        content: ""
      },
    {
        id: 10,
        href: "https://ldstr.dev/docs/development/",
        title: "Development",
        description: "Developer's guide to Lodestar.",
        content: ""
      },
    {
        id: 11,
        href: "https://ldstr.dev/docs/",
        title: "Docs",
        description: "Documentation for Lodestar.",
        content: ""
      },
    {
        id: 12,
        href: "https://ldstr.dev/docs/prologue/",
        title: "Prologue",
        description: "Prologue Lodestar.",
        content: ""
      },
    {
        id: 13,
        href: "https://ldstr.dev/docs/recipes/",
        title: "Recipes",
        description: "Code recipes for Lodestar.",
        content: ""
      },
    ];
  */

  // https://discourse.gohugo.io/t/range-length-or-last-element/3803/2

  index.add(
    {
        id: 0,
        href: "/docs/concepts/features/",
        title: "Features",
        description: "Lodestar's feature list.",
        content: " Automatic resolution of circular data-dependencies (algebraic loops). Transparent compile-time error checking, as well as run-time checks prior to executing code. Easy extensibility with a simple yet powerful Block API based on template metaprogramming. Clean C++ code generation with predetermined function execution order, as well as resolved data-dependencies. Zero-overhead abstraction using templated classes; it does not matter if you have a thousand inputs, or just one. Out-of-the-box networking support, with efficient serialization. Automatic direct encryption and decryption of messages for enhanced security using state-of-the-art elliptic curve algorithms.  Control Routines # For now, this section will be a checkboxed list; more details will follow. We adhere in most cases to the classification system used in SLICOT1. Cursive identifiers are extensions to the SLICOT system that we devised for additional features that Lodestar provides.\n  A: Analysis Routines\n AB: State-Space Analysis  AB04: Continuous/Discrete Time  AB04MD: Discrete-time \u0026lt;-\u0026gt; continuous-time conversion by bilinear transformation. - Generalized bilinear transformations have been implemented, with specialization for Tustin, Euler, and backward differencing transforms.\nls::analysis::BilinearTransformation - Beyond the SLICOT spec, zero-order hold transformations based on exponential and logarithmic matrices have been implemented.\nls::analysis::ZeroOrderHold   AB07: Inverse and Dual Systems  AB07ND: Inverse of a given state-space representation  Continuous-time state space inverses have been implement, but error handling is not properly done. ls::analysis::LinearSystemInverse          F: Filtering\n FB: Kalman Filters  FB01: N/A  FB01VD: One recursion of the conventional Kalman filter - We currently have an implementation for finite horizon Kalman gain computation for discrete-time linear time invariant systems.\nls::filter::DiscreteLQE        S: Synthesis Routines\n SB: State-Space Synthesis  SB02: Riccati Equations  SB02MD: Solution of continuous- or discrete-time algebraic Riccati equations (Schur vectors method) - A discrete-time ARE solver is currently in development.\nls::synthesis::AlgebraicRiccatiEquation::solveDARE        T: Transformation Routines\n TD: Rational Matrix  TD05: Rational Matrix to State-Space Conversion  TD05AD: Minimal state-space representation for a proper transfer matrix - This is currently implemented for scalar transfer functions, but can easily be extended to transfer function matrices.\nls::systems::TransferFunction::toStateSpace        U: Utility Routines\n UD: Numerical Data Handling  UD01: N/A  UD01BD: Reading a matrix polynomial  This is achieved using GiNaC2 routines; currently only scalar transfer functions are implemented, but this is easily extendable.\nls::systems::TransferFunction::copyFromExpression       US: Symbolic Manipulation/Data Handling  US01: Ordinary Differential Equations        SLICOT: Subroutine Library in Systems and Control Theory.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n GiNaC: GiNac is Not a CAS (Computer Algebra System).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "
      })
      .add(
      {
        id: 1,
        href: "/docs/development/codestyle/",
        title: "Code Style",
        description: "Lodestar's coding guidelines.",
        content: "⚠️  This is a work-in-progress.   #ifndef LODESTAR_CONTAINER_HPP #define LODESTAR_CONTAINER_HPP #include \u0026lt;array\u0026gt; // Note that we do not use `using std` to limit namespace pollution/clashes // Preprocessor directives and their arguments should be in upper snake case #define STATIC_GET(ARRAY, IDX) std::get\u0026lt;IDX\u0026gt;(ARRAY) // Template arguments should be descriptive, written in upper camel case, and prefixed with T* template \u0026lt;typename TType\u0026gt; // Constexpr should be prefixed with K*, and the following word should be in lower camel case. constexpr TType \u0026amp;Kmax(const TType \u0026amp;a, const TType \u0026amp;b) { // K\u0026amp;R-style brace placement (preceded by a linebreak) for functions // Indents are 4 spaces deep return (int \u0026amp;) (a \u0026gt; b ? a : b); } // Global variables follow the same naming rules as other variables // Constant variables are prefixed with k* const static unsigned int kDefaultSize = 10; template \u0026lt;typename TType, unsigned int TSize = kDefaultSize\u0026gt; // Class names should be in upper camel case class Container { public: // Typedefs should be descriptive and are prefixed with TD* typedef std::array\u0026lt;TType, TSize\u0026gt; TDArray; Container() : array_(TDArray{}) {} explicit Container(const TDArray \u0026amp;array) : array_(array) {} explicit Container(const TDArray *array) : array_(*array) {} Container(const TDArray \u0026amp;array, const unsigned int end) : array_(TDArray{}) { unsigned int i = 0; while ((i \u0026lt; end) \u0026amp;\u0026amp; (i \u0026lt; TSize)) { array_[i] = array[i]; i++; } } // Use of lower camel case names is encouraged void clearArray() { for (unsigned int i = 0; i \u0026lt; TSize; i++) array_[i] = TType{}; } TType getElement(const unsigned int idx) const { return array_[idx]; } void setElement(const unsigned int idx, const TType \u0026amp;val) { array_[idx] = val; } TDArray copyArray() const { return array_; } void copyContainer(const Container \u0026amp;other) const { for (unsigned int i = 0; i \u0026lt; TSize; i++) array_[i] = other.getElement(i); } TType getFirst() const { return STATIC_GET(array_, 0); } TType getLast() const { return STATIC_GET(array_, Kmax(0, TSize - 1)); } const unsigned int kSize = TSize; protected: // Private/protected member variables are postfixed with *_ std::array\u0026lt;TType, TSize\u0026gt; array_; // Static members may be prefixed with z* in case of ambiguities template\u0026lt;unsigned int TSizeOther\u0026gt; Container\u0026lt;TType, TSize\u0026gt; zCopyContainer(const Container\u0026lt;TType, TSizeOther\u0026gt; \u0026amp;other) { Container\u0026lt;TType, TSize\u0026gt; container{}; unsigned int i = 0; while ((i \u0026lt; other.kSize) \u0026amp;\u0026amp; (i \u0026lt; TSize)) container.setElement(i, other.getElement(i)); return container; } } // Preprocessor directives should be undef'd if they are not part of the public API #undef STATIC_GET #endif //LODESTAR_CONTAINER_HPP  "
      })
      .add(
      {
        id: 2,
        href: "/docs/blocks/gainblock/",
        title: "GainBlock",
        description: "Multiplication or convolution by a constant value.",
        content: "Description # Multiplies/convolves input by a value (gain).\nInterface Definition # GainBlock\u0026lt;TInput, TGain, TOps, TConv\u0026gt;\nTemplate Parameters #    Index Parameter type Name Description Default value     0 typename TInput Input value type -   1 typename TGain Gain value type TInput   2 GainBlockOperator TOps Gain block operator type ::Left   3 GainBlockConvolutionMode TConv Gain block convolution type ::Reflect    Inputs #    Index Parameter type Name Description Default value     0 \u0026lt;TInput\u0026gt; - Input value -    Outputs #    Index Parameter type Name Description Default value     0 \u0026lt;TOutput\u0026gt; - Output value -    Determination of TOutput is not straightforward; in the case of multiplication, we must first check if multiplication is possible. In the case of a scalar gain, or convolution, the output type is the same as TInput.\nParameters #    Index Parameter type Name Description Default value     0 \u0026lt;TGain\u0026gt; gain Gain value -   1 double constant Constant value -    The function of gain varies with TOps; see Effects.\nEffects # If TOps is:\n ::Left, left-multiply the input by the gain. ::Right, right-multiply the input by the gain. ::Convolution, convolve the input with the gain, where the boundary condition is determined by TConv.  If TOps is ::Convolution, and TConv is:\n ::Reflect, reflect about the edge of the last pixel. Also known as half-sample symmetric. ::Constant, fill all values beyond edges with a constant value (see parameter 1 in Parameters). ::Nearest, extend by replicating last pixel. ::Mirror, extend by reflecting about the center of the last pixel. Also known as whole-sample symmetric. ::Wrap, wrap around to the opposing edge.  Static Asserts #  Multiplicability in case of TOps in {::Left, ::Right}. Scalar type congruence in case of TOps = ::Convolution.  "
      })
      .add(
      {
        id: 3,
        href: "/docs/prologue/introduction/",
        title: "Introduction",
        description: "Lodestar is a lightweight C++11 framework for rapidly prototyping and deploying real-time control systems.",
        content: "Lodestar aims to be a framework that provides directly executable code, unlike most modeling and simulation-centric toolboxes, which have not been tailored for use in real-time applications. At the same time, Lodestar also allows for code generation when performance is particularly important. It comes built-in with many compile-time checks that cover most common typos and bugs (i.e., matrix-vector dimensions mismatch, connecting inputs to inputs, etc.).\nTo this end, Lodestar adopts a function block description of systems, where each Block provides a pure function (i.e., one that only alters its internal state). Each of these block may have any number of inputs, parameters, and outputs. The resulting functional block diagrams can easily be extended with new user-defined block types, without incurring overhead.\n Parameters +-----------------------------------------+ Inputs ---\u0026gt;| Block : f(Input, Parameters) -\u0026gt; Outputs |---\u0026gt; Outputs +-----------------------------------------+  Features #  Automatic resolution of circular data-dependencies (algebraic loops). Transparent compile-time error checking, as well as run-time checks prior to executing code. Easy extensibility with a simple yet powerful Block API based on template metaprogramming. Clean C++ code generation with predetermined function execution order, as well as resolved data-dependencies. Zero-overhead abstraction using templated classes; it does not matter if you have a thousand inputs, or just one. Out-of-the-box networking support, with efficient serialization. Automatic direct encryption and decryption of messages for enhanced security using state-of-the-art elliptic curve algorithms.  Getting Started # Dependencies #  CMake A C++11-compliant compiler GiNaC (optional, for resolving algebraic loops) nng (optional, for networking)  Building # Simply clone the repository and build using CMake. If you just want to grab a static library, run cmake .. instead of a debug build.\n Installing/disabling dependencies You can install the dependencies as follows:\n On Ubuntu (Debian): sudo apt-get install libginac-dev libcln-dev libnng-dev   On macOS: brew install ginac nng    You can disable GiNaC and NNG using the -DWITH_GINAC=OFF -DWITH_NNG=OFF flags when running the cmake command:\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DWITH_GINAC=OFF -DWITH_NNG=OFF\n git clone https://github.com/helkebir/Lodestar cd Lodestar mkdir build \u0026amp;\u0026amp; cd build cmake .. -DCMAKE_BUILD_TYPE=Debug make sudo make install  You can find some demos in the examples/ folder, as well as unit tests of different components in the tests/ folder.\n"
      })
      .add(
      {
        id: 4,
        href: "/docs/recipes/pid/",
        title: "PID Controller",
        description: "A simple proportional-integral-derivative controller.",
        content: "❓  For more background on PID controllers, see this theory page.   In this recipe, we will prepare a simple discretized PID controller. As a bonus, we show how to take this prebaked controller to the next level by programming a PID controller with anti-windup from scratch.\nGathering the Ingredients # You will need the following standard library blocks:\n ConstantBlock, for a constant setpoint. SumBlock, to add and subtract signals. GainBlock, to multiply signals with a fixed gain.  Include them as follows:\n#include \u0026lt;Lodestar/blocks/std/ConstantBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/SumBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/GainBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/SimplePIDBlock.hpp\u0026gt;  To make life easier for ourselves and reduce the amount of typing, let\u0026rsquo;s add the following two using namespace declarations:\nusing namespace ls::blocks; using namespace ls::blocks::std;  ⚠️  Using `using` declarations pollutes your namespace and can cause name clashes; use them in moderation.   Preparing the Blocks # We start by declaring our constant setpoint, which we assume to be a double:\nConstantBlock\u0026lt;double\u0026gt; constBlk{0.5};  You can change the constant any time before running the loop as follows:\nconstBlk.constant() = -0.5;  ⚠️  Don't change constants while your program is running; there are better ways of doing this (shown just below).   Now it\u0026rsquo;s time to introduce the summation that computes our error (setpoint minus the system\u0026rsquo;s output):\n// The number of inputs to the summation is 2, and the type is `double`, hence \u0026lt;double, 2\u0026gt;. SumBlock\u0026lt;double, 2\u0026gt; sumBlk;  You should know that a SumBlock assumes that all its inputs should just be added; we want to subtract the second input. To do this, we set the operators as follows:\nsumBlk.setOperators(decltype(sumBlk)::Plus, decltype(sumBlk)::Minus);  At this point, everything is ready for a PID controller. We are taking a shortcut here, directly using the SimplePIDBlock (don\u0026rsquo;t worry, a more advanced example follows just after this).\nSimplePIDBlock\u0026lt;double\u0026gt; pidBlk; pidBlk.pGain() = 1; pidBlk.iGain() = 0.2; pidBlk.dGain() = 0.1; pidBlk.samplingPeriod() = 1e-3;  Based on the code above, it should be clear that we are setting the proportional, derivative, and integral gains, as well as the sampling period, in that exact order. We link these blocks together next.\nLinking the Blocks # We will need to introduce two more includes add the top of the code: one for our connect function, and the other for the Executor, which will figure out how to run our blocks.\n#include \u0026lt;Lodestar/blocks/BlockUtilities.hpp\u0026gt; // connect function #include \u0026lt;Lodestar/blocks/aux/Executor.hpp\u0026gt; // Executor  We\u0026rsquo;re now getting to the fun part: connecting the blocks. It should be quite obvious to see what we\u0026rsquo;re after: the error should go into the PID block, and the constant should go into the first input of the sum.\nconnect(sumBlk.o\u0026lt;0\u0026gt;(), pidBlk.i\u0026lt;0\u0026gt;()); connect(constBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;0\u0026gt;());  Here\u0026rsquo;s a pro tip for when you start taking on more advanced systems; you can alias signals as follows:\nauto \u0026amp;e = sumBlk.o\u0026lt;0\u0026gt;(); auto \u0026amp;s0 = sumBlk.i\u0026lt;0\u0026gt;(); auto \u0026amp;s1 = sumBlk.i\u0026lt;1\u0026gt;(); auto \u0026amp;sp = constBlk.o\u0026lt;0\u0026gt;(); auto \u0026amp;pid = pidBlk.i\u0026lt;0\u0026gt;(); auto \u0026amp;u = pidBlk.o\u0026lt;0\u0026gt;(); connect(sp, s0); connect(e, pid);  If you keep track of your naming conventions, this can feel a lot closer to drawing a block diagram by hand!\nExecuting the Program # We\u0026rsquo;re missing one crucial component: a physical system. This is were the possibilities start to expand; you can declare your own blocks in Lodestar and directly interface with them.\nFor now, let\u0026rsquo;s keep things simple, going for a one-step time delay (DelayBlock) instead:\n#include \u0026lt;Lodestar/blocks/std/DelayBlock.hpp\u0026gt; DelayBlock\u0026lt;double\u0026gt; sysBlk; // Set the initial value to be 5. sysBlk.clear(5);  The final interconnections read:\nconnect(pidBlk.o\u0026lt;0\u0026gt;(), sysBlk.i\u0026lt;0\u0026gt;()); connect(sysBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;1\u0026gt;());  Or, in case you\u0026rsquo;re using those handy aliases:\nconnect(u, sysBlk.i\u0026lt;0\u0026gt;()); connect(sysBlk.o\u0026lt;0\u0026gt;(), s1);  ⚠️  Be aware of your `connection`s; Lodestar will complain if you connect incompatible signals, or if you try to connect two or more outputs to a single input. Also, you can't use and input as an output (for obvious reasons).   We\u0026rsquo;re now ready to run the code. First, however, we need to let Lodestar know what we\u0026rsquo;re working with. To do that, Lodestar uses BlockPacks; as the name suggests, these are packs of blocks:\nBlockPack bp{pidBlk, constBlk, sumBlk, sysBlk};  Now, we can pass this BlockPack to an Executor, which allows us to resolve the execution order:\naux::Executor ex{bp}; ex.resolveExecutionOrder();  That\u0026rsquo;s it, you can now run a single iteration of your loop (known as triggering in Lodestar parlance):\nex.trigger();  To actually see our program in action, let\u0026rsquo;s include \u0026lt;iostream\u0026gt;, and run the following code:\nfor (int i=0; i\u0026lt;50; i++) { ex.trigger(); // Print the system output ::std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; sysBlk.o\u0026lt;0\u0026gt;().object \u0026lt;\u0026lt; ::std::endl; }  And there you have it, your first PID controller in Lodestar!\nGoing Beyond # We will need some more blocks to cook up our advanced PID controller:\n SaturationBlock, to limit our integral value. DeadzoneBlock, to prevent small oscillations in case of small errors. DelayBlock, to be able to perform Euler integration and backward differentiation.  #include \u0026lt;Lodestar/blocks/std/SaturationBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/DeadzoneBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/DelayBlock.hpp\u0026gt;  Now, for the block initialization:\nGainBlock\u0026lt;double\u0026gt; Kp{1}; GainBlock\u0026lt;double\u0026gt; Ki{0.2}; GainBlock\u0026lt;double\u0026gt; Kd{0.1}; GainBlock\u0026lt;double\u0026gt; periodInv{1e3}; GainBlock\u0026lt;double\u0026gt; period{1e-3}; DelayBlock\u0026lt;double\u0026gt; delayDiff, delayInt; SaturationBlock\u0026lt;double\u0026gt; satInt; satInt.lower() = -1; satInt.upper() = 1; SumBlock\u0026lt;double, 2\u0026gt; sumDiff, sumInt; sumDiff.setOperators(decltype(sumDiff)::Plus, decltype(sumDiff)::Minus); SumBlock\u0026lt;double, 3\u0026gt; sumPID; SaturationBlock\u0026lt;double\u0026gt; satBlk; satBlk.lower() = -2; satBlk.upper() = 2; DeadzoneBlock\u0026lt;double\u0026gt; dzBlk; dzBlk.lower() = -0.05; dzBlk.upper() = 0.05;  You can see that we introduced a couple of gains, some delays and sums, and a saturation and deadzone block. Initializing these block is pretty straightforward as shown. We can now start linking them together.\n// Proportional connect(sumBlk.o\u0026lt;0\u0026gt;(), Kp.i\u0026lt;0\u0026gt;()); connect(Kp.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;0\u0026gt;()); // Integral connect(sumInt.o\u0026lt;0\u0026gt;(), satInt.i\u0026lt;0\u0026gt;()); connect(satInt.o\u0026lt;0\u0026gt;(), delayInt.i\u0026lt;0\u0026gt;()); connect(delayInt.o\u0026lt;0\u0026gt;(), sumInt.i\u0026lt;0\u0026gt;()); connect(sumBlk.o\u0026lt;0\u0026gt;(), period.i\u0026lt;0\u0026gt;()); connect(period.o\u0026lt;0\u0026gt;(), sumInt.i\u0026lt;1\u0026gt;()); connect(satInt.o\u0026lt;0\u0026gt;(), Ki.i\u0026lt;0\u0026gt;()); connect(Ki.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;1\u0026gt;()); // Differential connect(sumBlk.o\u0026lt;0\u0026gt;(), sumDiff.i\u0026lt;0\u0026gt;()); connect(sumBlk.o\u0026lt;0\u0026gt;(), delayDiff.i\u0026lt;0\u0026gt;()); connect(delayDiff.o\u0026lt;0\u0026gt;(), sumDiff.i\u0026lt;1\u0026gt;()); connect(sumDiff.o\u0026lt;0\u0026gt;(), periodInv.i\u0026lt;0\u0026gt;()); connect(periodInv.o\u0026lt;0\u0026gt;(), Kd.i\u0026lt;0\u0026gt;()); connect(Kd.o\u0026lt;0\u0026gt;(), sumPID.i\u0026lt;2\u0026gt;()); // Error computation connect(constBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;0\u0026gt;()); connect(dzBlk.o\u0026lt;0\u0026gt;(), sumBlk.i\u0026lt;1\u0026gt;()); // Saturation connect(sumPID.o\u0026lt;0\u0026gt;(), satBlk.i\u0026lt;0\u0026gt;()); // Deadzone connect(sysBlk.o\u0026lt;0\u0026gt;(), dzBlk.i\u0026lt;0\u0026gt;()); // Control interconnection connect(satBlk.o\u0026lt;0\u0026gt;(), sysBlk.i\u0026lt;0\u0026gt;());  Most of the code above is straightforward, but the integral and differential parts might need to be reread to see how things link up. This is where a block diagram could come in handy (Lodestar can generate those for you, but we\u0026rsquo;ll get into that in another article!).\nThe BlockPack-Executor interaction is the same as above, but now we have a couple more blocks to declare:\nBlockPack bp{sysBlk, constBlk, sumBlk, satBlk, sumDiff, sumInt, sumPID, satInt, Kp, Ki, Kd, period, periodInv, delayInt, delayDiff}; aux::Executor ex{bp}; ex.resolveExecutionOrder();  Try running the code below and see what has changed:\nfor (int i=0; i\u0026lt;50; i++) { ex.trigger(); // Print the system output ::std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; sysBlk.o\u0026lt;0\u0026gt;().object \u0026lt;\u0026lt; ::std::endl; }  "
      })
      .add(
      {
        id: 5,
        href: "/docs/concepts/rationale/",
        title: "Rationale",
        description: "Rationale behind Lodestar.",
        content: "The greatest driver behind this project is the lack of a fast and accessible library for applying control theoretic concepts on real-life (embedded) systems. While platforms such as ROS1 are popular in robotics, people working with applications that require real-time viable code and thread safety are often compelled to write their own solutions, with propiertary implementations being the norm, and a single unified solution is left to be desired.\nWith this in mind, I set out to develop a unified and approachable control library, with the explicit intention to make it as real-time viable as possible while maintaining code transparency and providing a flexible API2.\nFor more information, please check out our paper on arXiv entitled \u0026ldquo;Lodestar: An Integrated Embedded Real-Time Control Engine\u0026rdquo;.\nCore Principles # Lodestar is built on the following core principles:\n Firm real-time first:  Memory demands should be known at compile-time, minimum/no dynamic memory allocation/paging. Dynamically and statically allocated objects should share a common API. Exceptions should be thrown with care; status-based fallbacks are preferred. Processes should be timed, with fallback mechanisms and deadline violation reporting.   Wide platform support:  Maintain minimum demands should be imposed on compiled libraries, preferring header-only libraries instead. Use only ISO/ANSI C++11 features. Make full use of POSIX3 RT (real-time) mechanisms (pthreads, sigactions, etc.).   Flexible interfacing and extension:  Extendible, documented, and transparent core API. Inproc and outproc non-blocking communication framework. Thread-safe data types, with object-bound mutexes.    Levels of Real-time # The following is a common classification of levels of real-time:\n Soft real-time: Delayed process completion may degrade a system\u0026rsquo;s quality of service, but is tolerable. Firm real-time: Delayed process completion may degrade a system\u0026rsquo;s quality of service, but is tolerable if infrequent. Hard real-time: Delayed process completion results in system failure.  At least for the initial stages, Lodestar will try to get to the level where one could reliably call it a firm real-time framework. With sufficient testing and profiling in a hardware emulator, it is possible to extend a firm real-time system to a hard real-time system, but it could be the case that additional safety features and fallbacks are expected. This is, for now, beyond the scope of the library.\n  ROS: Robot Operating System.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n API: Application Programming Interface.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n POSIX: Portable Operating System Interface, a family of standards described in IEEE 1003 and ISO/IEC 9945.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "
      })
      .add(
      {
        id: 6,
        href: "/docs/recipes/lqr/",
        title: "LQR Controller",
        description: "A linear quadratic regulator.",
        content: "⚠️  This is a work-in-progress.   See this example for now.\n"
      })
      .add(
      {
        id: 7,
        href: "/docs/prologue/quick-start/",
        title: "Quick Start",
        description: "How to get started with Lodestar.",
        content: "Dependencies #  CMake A C++11-compliant compiler GiNaC (optional, for resolving algebraic loops) nng (optional, for networking)  Building # Simply clone the repository and build using CMake. If you just want to grab a static library, run cmake .. instead of a debug build.\n Installing/disabling dependencies You can install the dependencies as follows:\n On Ubuntu (Debian): sudo apt-get install libginac-dev libcln-dev libnng-dev   On macOS: brew install ginac nng    You can disable GiNaC and NNG using the -DWITH_GINAC=OFF -DWITH_NNG=OFF flags when running the cmake command:\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DWITH_GINAC=OFF -DWITH_NNG=OFF\n  git clone https://github.com/helkebir/Lodestar cd Lodestar mkdir build \u0026amp;\u0026amp; cd build cmake .. -DCMAKE_BUILD_TYPE=Debug make sudo make install  You can find some demos in the examples/ folder, as well as unit tests of different components in the tests/ folder.\nFirst Example # Here\u0026rsquo;s an example to get you started. We will be using ConstantBlock, SumBlock, and GainBlock objects to construct a simple program.\n#include \u0026lt;Lodestar/blocks/std/ConstantBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/SumBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/std/GainBlock.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/BlockUtilities.hpp\u0026gt; #include \u0026lt;Lodestar/blocks/aux/Executor.hpp\u0026gt; using namespace ls::blocks; using namespace ls::blocks::std; /* * (+) * +---+ +---+ +---+ * | c |---\u0026gt;| g |---\u0026gt;| s |---\u0026gt; * +---+ +---+ +---+ * ^ (-) * +----+ | * | c2 |--------------+ * +----+ */ int main() { ConstantBlock\u0026lt;double\u0026gt; c{5}, c2{2}; SumBlock\u0026lt;double, 2\u0026gt; s; GainBlock\u0026lt;double\u0026gt; g{0.5}; s.setOperators(decltype(s)::Plus, decltype(s)::Minus); // We now establish the interconnections: connect(c.o\u0026lt;0\u0026gt;(), g.i\u0026lt;0\u0026gt;()); connect(g.o\u0026lt;0\u0026gt;(), s.i\u0026lt;0\u0026gt;()); connect(c2.o\u0026lt;0\u0026gt;(), s.i\u0026lt;1\u0026gt;()); // We group all our blocks in a BlockPack object, // which contains all components of our system. BlockPack bp{c, c2, s, g}; // We pass the BlockPack onto the Executor, // which will allow us to resolve the execution order, // providing a single trigger function for the entire system. aux::Executor ex{bp}; ex.resolveExecutionOrder(); // Triggering the entire system is as simple as // calling the trigger function of the executor. ex.trigger(); // We obtain +5*0.5 -2 = 0.5 auto res = (s.o\u0026lt;0\u0026gt;().object == 0.5); return 0; }  Next Steps # Look around in the sidebar on the left to read on whatever topic is of direct interest. We recommend browsing through the Concepts tab, especially the Rationale. Some assorted code snippets and recipes are laid out in the Recipes section. If you want to directly dive into the source code, check out the C++ reference.\n"
      })
      .add(
      {
        id: 8,
        href: "/docs/blocks/",
        title: "Blocks",
        description: "Lodstar blocks.",
        content: ""
      })
      .add(
      {
        id: 9,
        href: "/docs/concepts/",
        title: "Concepts",
        description: "Lodestar concepts.",
        content: ""
      })
      .add(
      {
        id: 10,
        href: "/docs/development/",
        title: "Development",
        description: "Developer's guide to Lodestar.",
        content: ""
      })
      .add(
      {
        id: 11,
        href: "/docs/",
        title: "Docs",
        description: "Documentation for Lodestar.",
        content: ""
      })
      .add(
      {
        id: 12,
        href: "/docs/prologue/",
        title: "Prologue",
        description: "Prologue Lodestar.",
        content: ""
      })
      .add(
      {
        id: 13,
        href: "/docs/recipes/",
        title: "Recipes",
        description: "Code recipes for Lodestar.",
        content: ""
      })
      ;

  search.addEventListener('input', show_results, true);

  function show_results(){
    const maxResult = 5;
    var searchQuery = this.value;
    var results = index.search(searchQuery, {limit: maxResult, enrich: true});

    // flatten results since index.search() returns results for each indexed field
    const flatResults = new Map(); // keyed by href to dedupe results
    for (const result of results.flatMap(r => r.result)) {
      if (flatResults.has(result.doc.href)) continue;
      flatResults.set(result.doc.href, result.doc);
    }

    suggestions.innerHTML = "";
    suggestions.classList.remove('d-none');

    // inform user that no results were found
    if (flatResults.size === 0 && searchQuery) {
      const noResultsMessage = document.createElement('div')
      noResultsMessage.innerHTML = `No results for "<strong>${searchQuery}</strong>"`
      noResultsMessage.classList.add("suggestion__no-results");
      suggestions.appendChild(noResultsMessage);
      return;
    }

    // construct a list of suggestions
    for(const [href, doc] of flatResults) {
        const entry = document.createElement('div');
        suggestions.appendChild(entry);

        const a = document.createElement('a');
        a.href = href;
        entry.appendChild(a);

        const title = document.createElement('span');
        title.textContent = doc.title;
        title.classList.add("suggestion__title");
        a.appendChild(title);

        const description = document.createElement('span');
        description.textContent = doc.description;
        description.classList.add("suggestion__description");
        a.appendChild(description);

        suggestions.appendChild(entry);

        if(suggestions.childElementCount == maxResult) break;
    }
  }
}());
